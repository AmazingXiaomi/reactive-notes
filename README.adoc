= Notes on Reactive Programming

include::intro.adoc[leveloffset=+1]

== Basics of Reactive Programming in Java

include::flux.adoc[leveloffset=+1]

== Concurrent Programming

include::io.adoc[leveloffset=+1]

== Server Platforms

include::platform.adoc[leveloffset=+1]

TODO: more chat to tidy up

```
Tomcat 8.0 is already Servlet 3.1 compliant, which is what we need

If I remember correctly, Tomcat 8.5 is major refactoring that was supposed to be in 9.x, but since the Servlet 4 spec took so long Mark decided to release separate of that

David Syer [10:53 AM] 
There must be a downside then?

Servlet 3.1 is not the bees knees, from what I dimly understand eavesdropping here

Arjen Poutsma [10:53 AM] 
nope

for optimal reactiveness, use a Netty-based solution

David Syer [10:54 AM] 
Define "optimal"

Arjen Poutsma [10:56 AM] 
the servlet 3.1 asynchronous model is ultimately based on a synchronous underlying API

so rather than exposing Futures or similar constructs, it exposes listeners, and you get a callback when you can read from/write to the ServletInput/OutputStream

such a solution will only get you so far

not to mention that it is still byte[]-based, and does not expose ByteBuffers in any way

to be honest, there is no way to answer your question yet, as we haven’t done any serious performance testing. But we ​*expect*​ Netty to be a better fit, since its threading model is more close aligned to a reactive world. Servlet containers still use a one-thread-per-request model, even if you are using the async support

David Syer [11:02 AM] 
Brilliant.

Arjen Poutsma [11:03 AM] 
so threading is reason one, exposing byte buffers is reason two for preferring netty

David Syer [11:03 AM] 
But buffers are just more efficient?

Because of heap memory?

Arjen Poutsma [11:03 AM] 
yes

and non-blockingness of the java.nio API
```

== The Role of Back Pressure

* `subscribeOn()` allows a `Flux` to relay a slow publisher

* `publishOn()` allows a `Flux` to have slow subscribers

TODO: tidy this up...

since callback is called for each subscriber you can use operators that share a context


```
Mono.defer( () -> {
  AtomicInteger d = new AtomicNumber();     
  return Mono.just(1)
             .map(d::incrementAndGet)
             .doOnError(d::decrementAndGet);
})
```

`d` here is scoped for a given `Subscriber` that can be useful

== Don't Be the Bottleneck

Do you need to know all this stuff? Possibly not. You can be the bottleneck, if you are confident that you are no worse than your downstream dependencies. You might as well stick with plain old imperative programming and synchronous request-response. Use a few background threads to grease your way a bit. The result is easier to understand and easier to operationalize.

== Links

http://blog.paralleluniverse.co/2014/02/20/reactive/[Parallel universe blog on Reactive]

http://www.javaworld.com/article/2071370/core-java/of-fibers-and-continuations.html[Of Fibers and Continuations | JavaWorld]

Readable (but unfortunately database-biased) article:
http://news.dice.com/2014/01/13/how-is-reactive-different-from-procedural-programming/[How is Reactive Programming Different?]

Propaganda: 
http://www.reactivemanifesto.org/[The Reactive Manifesto]

http://www.reactive-streams.org/[Reactive Streams]

Blog from RxJava lead http://akarnokd.blogspot.co.uk/[David Karnok] including the one on http://akarnokd.blogspot.co.uk/2016/03/operator-fusion-part-1.html[Generations of Reactive]

https://github.com/reactor/reactive-streams-commons/issues/21(Reactive Gems) github issue with documentation of lots of use cases

https://en.wikipedia.org/wiki/Continuation(which you can think of as state)[Continuation - Wikipedia]

A multilingual framework (including Java):
https://github.com/kentuckyfriedtakahe/sodium[Sodium - GitHub]

http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html[Fork-join docs at Oracle]

Sebastien Deleuze's https://spring.io/blog/2016/04/19/understanding-reactive-types[Reactive Types] Blog

https://lmax-exchange.github.io/disruptor/[LMAX Disruptor]