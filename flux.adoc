In this second article on Reactive Programming, we concentrate on explaining some concepts through actual code samples. The end result should be that you understand the power of the Reactive approach, but remember that with power comes responsibility. It's radical, and it's fundamental. It's "rip it up and start again" territory. So you will also hopefully appreciate that Reactive isn't a solution to all problems. In fact it isn't a solution to any problem, it merely facilitates the solution of a certain class of problems. The benefits you get from using it might be outweighed by the costs of learning it and maintaining the code afterwards, so tread carefully.

== Setting Up a Project

We will use the Reactor libraries and a bit of Spring 5.0 to illustrate the points we need to make. The code could just as easily be written with other tools. If you want to play with the code and see it working without having to copy-paste anything, there are working samples with tests in https://github.com/dsyer/reactive-notes[Github].

To get started grab a blank project from https://start.spring.io and add the Reactor Core dependency. With Maven 

```xml
		<dependency>
			<groupId>io.projectreactor</groupId>
			<artifactId>reactor-core</artifactId>
		</dependency>
```

Also set the version explicitly in the dependency or as a property:

```xml
<properties>
    ...    
    <reactor.version>2.5.0.BUILD-SNAPSHOT</reactor.version>
</properties>
```

With Gradle it's very similar:

```java
    compile 'io.projectreactor:reactor-core:2.5.0.BUILD-SNAPSHOT'
```

Now let's write some code.

== What Makes it Functional?

The basic building block of Reactive is a stream of events, and two protagonists, a publisher and a subscriber to those events. It's OK to call it a "stream" because that's what it is. If we need to, we will use the word "stream" with a small "s", but Java 8 has a `java.util.Stream` which is different, so try not to get confused. We wil try to concentrate the narrative on the publisher and subscriber anyway (that's what Reactive Streams does).

Reactor is the library we are going to use in samples, so we'll stick to the notation there, and call the publisher a `Flux` (it implements the interface `Publisher` from Reactive Streams). The RxJava library is very similar and has a lot of parallel features, so in that case we would be talking about an `Observable` instead, but the code would be very similar. (Reactor 2.0 called it a `Stream` which is confusing if we need to talk about Java 8 `Streams` as well, so we'll only use the new code in Reactor 2.5.)

=== Generators

A `Flux` is a publisher of a stream of events of a specific POJO type, so it is generic, i.e. `Flux<T>` is a publisher of `T`. `Flux` has some static convenience methods to create instances of itself from a variety of sources. For example, to create a `Flux` from a collection (or iterable):

```java
Flux<String> flux = Flux.just("red", "white", "blue");
```

We just generated a `Flux`, and now we can do stuff with it. There are actually only two things you can do with it: operate on it (transform it, or combine it with other streams) or subscribe to it (as it's a publisher).

=== Single Valued Streams

Often you encounter a stream that you know has only one or zero elements, for example a repository method that finds an entity by its id. Reactor has a `Mono` type representing a single valued or empty `Flux`. `Mono` has a very similar API to `Flux` but more focused because not all operators make sense for single-valued streams. RxJava also has a bolt on (in version 1.x) called `Single`, and also `Completable` for an empty stream.

=== Operators

There are a _lot_ of methods on a `Flux` and nearly all of them are operators. We aren't going to look at them all here because there are better places to look for that (like the Javadocs). We only need to get a flavour for what an operator is, and what it can do for you.

For instance, to ask for the internal events inside a `Flux` to be logged to standard out, you can call the `.log()` method. Or you can transform it using a `map()`:

```java
Flux<String> flux = Flux.just("red", "white", "blue");

Flux<String> upper = flux
  .log()
  .map(value -> value.toUpperCase());
```

In this code we transformed the strings in the input by converting them to upper case. So far, so trivial.

What's interesting about this little sample -- mind blowing, even, if you're not used to it -- is that no data have been processed yet. Nothing has even been logged because literally, nothing happened (try it and you will see). Calling operators on a `Flux` amounts to building a plan of execution for later. It is completely declarative, and it's why people call it "functional". The logic implemented in the operators is only executed when data starts to flow, and that doesn't happen until someone subscribes to the `Flux` (or equivalently to the `Publisher`).

The same declarative, functional approach to processing a stream of data exists in all Reactive libraries, and also in Java 8 `Streams`. Consider this, similar looking code, using a `Stream` with the same contents as the `Flux`:

```java
Stream<String> stream = Streams.of("red", "white", "blue");
Stream<String> upper = stream.map(value -> {
    System.out.println(value);
    return value.toUpperCase();
});
```

The observation we made about `Flux` applies here: no data is processed, it's just a plan of execution. There are, however, some important differences between `Flux` and `Stream` though, which make `Stream` an inappropriate API for Reactive use cases. `Flux` has a lot more operators, much of which is just convenience, but the real difference comes when you want to consume the data, so that's what we need to look at next.

TIP: There is a useful blog by Sebastien Deleuze on https://spring.io/blog/2016/04/19/understanding-reactive-types[Reactive Types], where he describes the differences between the various streaming and reactive APIs by looking at the types they define, and how you would use them. The differences between `Flux` and `Stream` are highlighted there in more detail.

=== Subscribing

To make the data flow you have to subscribe to the `Flux` using one of the `subscribe()` methods. Only those methods make the data flow. They reach back through the chain of operators you declared on your stream (if any) and request the publisher to start creating data. In the sample samples we have been working with, this means the underlying collection of strings is iterated. In more complicated use case it might trigger a file to be read from the filesystem, or a pull from a database or a call to an HTTP service.

Here's a call to `subscribe()` in action:

```java
Flux.just("red", "white", "blue");
  .log()
  .map(value -> value.toUpperCase())
.subscribe()
```

The output is:

```
09:17:59.665 [main] INFO reactor.core.publisher.FluxLog -  onSubscribe(reactor.core.publisher.FluxIterable$IterableSubscription@3ffc5af1)
09:17:59.666 [main] INFO reactor.core.publisher.FluxLog -  request(unbounded)
09:17:59.666 [main] INFO reactor.core.publisher.FluxLog -  onNext(red)
09:17:59.667 [main] INFO reactor.core.publisher.FluxLog -  onNext(white)
09:17:59.667 [main] INFO reactor.core.publisher.FluxLog -  onNext(blue)
09:17:59.667 [main] INFO reactor.core.publisher.FluxLog -  onComplete()
```

So we can see from this that the effect of `subscribe()` without an argument, is to request the publisher to send _all_ data -- there's only one `request()` logged and it's "unbounded". We can also see callbacks for each item that is published (`onNext`), for the end of the stream (`onComplete`), and for the original subscription (`onSubscribe`). If you needed to you could listen for those events yourself using the `doOn*` methods in `Flux` (which are themselves operators, not subscribers, so they don't cause any data to flow on their own).

The other way to subscribe is with a call to `subscribe(...)` with callbacks as arguments. There is a convenient form that gives you a callback with all the items, and also optionally with an error if there is one, and when the stream is complete. For example, just with the per-item callback:

```java
Flux.just("red", "white", "blue");
    .log()
    .map(value -> value.toUpperCase())
.subscribe(System.out::println);
```

Here's the output:

```
09:56:12.680 [main] INFO reactor.core.publisher.FluxLog -  onSubscribe(reactor.core.publisher.FluxArray$ArraySubscription@59f99ea)
09:56:12.682 [main] INFO reactor.core.publisher.FluxLog -  request(unbounded)
09:56:12.682 [main] INFO reactor.core.publisher.FluxLog -  onNext(red)
RED
09:56:12.682 [main] INFO reactor.core.publisher.FluxLog -  onNext(white)
WHITE
09:56:12.682 [main] INFO reactor.core.publisher.FluxLog -  onNext(blue)
BLUE
09:56:12.682 [main] INFO reactor.core.publisher.FluxLog -  onComplete()
```

We could control the flow of data, and make it "bounded", in a variety of ways. The raw API for controlling it is the `Subscription` you get from a `Subscriber`. The equivalent long form of the short call to `subscribe()` above is:

```java
.subscribe(new Subscriber<String>() {

    @Override
    public void onSubscribe(Subscription s) {
        s.request(Long.MAX_VALUE);
    }
    @Override
        public void onNext(String t) {
    }
    @Override
        public void onError(Throwable t) {
    }
    @Override
        public void onComplete() {
    }

});
```

To control the flow, e.g. to consume at most 2 items at a time, you could use the `Subscription` more intelligently:

```java
.subscribe(new Subscriber<String>() {

    private long count = 0;
    private Subscription subscription;

    @Override
    public void onSubscribe(Subscription subscription) {
        this.subscription = subscription;
        subscription.request(2);
    }

    @Override
    public void onNext(String t) {
        count++;
        if (count>=2) {
            count = 0;
            subscription.request(2);
        }
     }
...
```

This `Subscriber` is "batching" items 2 at a time. It's a common use case so you might want to extract the implementation to a convenience class, and that would make the code more readable too. The output looks like this:

```
09:47:13.562 [main] INFO reactor.core.publisher.FluxLog -  onSubscribe(reactor.core.publisher.FluxArray$ArraySubscription@61832929)
09:47:13.564 [main] INFO reactor.core.publisher.FluxLog -  request(2)
09:47:13.564 [main] INFO reactor.core.publisher.FluxLog -  onNext(red)
09:47:13.565 [main] INFO reactor.core.publisher.FluxLog -  onNext(white)
09:47:13.565 [main] INFO reactor.core.publisher.FluxLog -  request(2)
09:47:13.565 [main] INFO reactor.core.publisher.FluxLog -  onNext(blue)
09:47:13.565 [main] INFO reactor.core.publisher.FluxLog -  onComplete()
```

In fact this is such a common use case that there are convenience methods already available in `Flux`:

```java
Flux.just("red", "white", "blue");
  .log()
  .map(value -> value.toUpperCase())
  .useCapacity(2)
.subscribe()
```

(note the call to `useCapacity()` before the subscription). The output:

```
10:25:43.739 [main] INFO reactor.core.publisher.FluxLog -  onSubscribe(reactor.core.publisher.FluxArray$ArraySubscription@4667ae56)
10:25:43.740 [main] INFO reactor.core.publisher.FluxLog -  request(2)
10:25:43.740 [main] INFO reactor.core.publisher.FluxLog -  onNext(red)
10:25:43.741 [main] INFO reactor.core.publisher.FluxLog -  onNext(white)
10:25:43.741 [main] INFO reactor.core.publisher.FluxLog -  request(2)
10:25:43.741 [main] INFO reactor.core.publisher.FluxLog -  onNext(blue)
10:25:43.741 [main] INFO reactor.core.publisher.FluxLog -  onComplete()
```
=== Threads, Dispatchers and Background Processing

An interesting feature of all the logs above is that they are all on the "main" thread, which is the thread of the caller to `subscribe()`. This highlights an important point: Reactor is extremely frugal with threads, because that gives you the greatest chance of the best possible performance. That might be a surprising statement if you've been wrangling threads and thread pools and asynchronous executions for the last 5 years, trying to squeeze more juice out of your services. But it's true: in the absence of any imperative to switch threads, even if the JVM is optimized to handle threads very efficiently, it is always faster to do computation on a single thread. Reactor has handed you the keys to control all the asynchronous processing, and it assumes you know what you are doing.

TODO: more stuff here

=== Converters: The Subscribers from Dark Side

There is another way to subscribe to a stream, which is to call a converter method. `Flux` has `toList()` and `toMap()` and `Mono` has `get()`.

WARNING: A good rule of thumb is "**never call get**" on `Mono` (or the equivalent converter methods on `Flux`).

These methods are only there as an escape hatch to bridge from Reactive to blocking, if you need to adapt to a legacy API, for instance. When you call `Mono.get()` you throw away all the benefits of the Reactive Streams. This is the key difference between Reactive Streams and Java 8 `Streams` -- the native Java `Stream` only has the "all or nothing" subscription model, the equivalent of `Mono.get()`.

== Conclusion

TODO: re-write this:

Do you need to know all this stuff? Possibly not. You can be the bottleneck, if you are confident that you are no worse than your downstream dependencies. You might as well stick with plain old imperative programming and synchronous request-response. Use a few background threads to grease your way a bit. The result is easier to understand and easier to operationalize.