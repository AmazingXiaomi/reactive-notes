:github: https://github.com/dsyer/reactive-notes
:master: {github}/blob/master
:partii: {master}/flux.adoc
:partiv: {master}/platform.adoc

In this article we continue the series on {partii}[Reactive Programming], and the focus is on more concrete use cases and writing code that actually does something useful. We will see how Reactive is a useful abstraction for concurrent programming, but also that it has some very low level features that we should learn to treat with respect and caution. If we start to use these features to their full potential we can take control of layers in our application that previously were invisible, hidden by containers, platforms and frameworks.

== Power and Responsibility

We may soon truly begin to see the power of the Reactive approach, but remember that with power comes responsibility. It's radical, and it's fundamental. It's "rip it up and start again" territory. So you will also hopefully appreciate that Reactive isn't a solution to all problems. In fact it isn't a solution to any problem, it merely facilitates the solution of a certain class of problems. The benefits you get from using it might be outweighed by the costs of learning it and maintaining the code afterwards, so tread carefully.